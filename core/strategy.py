"""
core/strategy.py - Trading Strategy Framework

This module provides a unified strategy execution engine for both
backtesting and replay modes. Strategies define entry/exit conditions
that are evaluated consistently regardless of execution mode.

Key Design Principles:
- No future data leakage (point-in-time evaluation)
- Same engine for backtest and replay
- Serializable strategy definitions
- Extensible condition system

Usage:
    # Define a strategy
    strategy = Strategy(
        name="MA Crossover",
        entry_conditions=[...],
        exit_conditions=[...],
        parameters={...}
    )
    
    # Save for later use
    save_strategy(strategy, "ma_crossover")
    
    # Execute in backtest mode
    engine = StrategyEngine(strategy)
    results = engine.execute(data, mode="backtest")
    
    # Execute in replay mode (same engine!)
    results = engine.execute(data, mode="replay")
"""

import json
import logging
from typing import Dict, List, Any, Optional, Literal
from pathlib import Path
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum

logger = logging.getLogger(__name__)


class ConditionType(Enum):
    """Types of strategy conditions."""
    PRICE_ABOVE = "price_above"
    PRICE_BELOW = "price_below"
    PRICE_CROSSES_ABOVE = "price_crosses_above"
    PRICE_CROSSES_BELOW = "price_crosses_below"
    INDICATOR_ABOVE = "indicator_above"
    INDICATOR_BELOW = "indicator_below"
    INDICATOR_CROSSES_ABOVE = "indicator_crosses_above"
    INDICATOR_CROSSES_BELOW = "indicator_crosses_below"
    AND = "and"
    OR = "or"
    NOT = "not"


@dataclass
class Condition:
    """A single strategy condition.
    
    Attributes:
        type: Type of condition (price, indicator, logical)
        params: Parameters for the condition
        children: Child conditions for logical operators (AND, OR, NOT)
    """
    type: str
    params: Dict[str, Any]
    children: Optional[List['Condition']] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        result = {
            "type": self.type,
            "params": self.params
        }
        if self.children:
            result["children"] = [c.to_dict() for c in self.children]
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Condition':
        """Create from dictionary."""
        children = None
        if "children" in data:
            children = [cls.from_dict(c) for c in data["children"]]
        return cls(
            type=data["type"],
            params=data["params"],
            children=children
        )


@dataclass
class Strategy:
    """A trading strategy definition.
    
    Attributes:
        name: Strategy name
        description: Human-readable description
        entry_conditions: List of conditions that trigger entry
        exit_conditions: List of conditions that trigger exit
        parameters: Strategy parameters (timeframes, thresholds, etc.)
        metadata: Additional metadata (created date, version, etc.)
    """
    name: str
    description: str
    entry_conditions: List[Condition]
    exit_conditions: List[Condition]
    parameters: Dict[str, Any]
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Initialize metadata if not provided."""
        if self.metadata is None:
            self.metadata = {
                "created_at": datetime.now().isoformat(),
                "version": "1.0"
            }
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "name": self.name,
            "description": self.description,
            "entry_conditions": [c.to_dict() for c in self.entry_conditions],
            "exit_conditions": [c.to_dict() for c in self.exit_conditions],
            "parameters": self.parameters,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Strategy':
        """Create from dictionary."""
        return cls(
            name=data["name"],
            description=data["description"],
            entry_conditions=[Condition.from_dict(c) for c in data["entry_conditions"]],
            exit_conditions=[Condition.from_dict(c) for c in data["exit_conditions"]],
            parameters=data["parameters"],
            metadata=data.get("metadata")
        )
    
    def to_json(self) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=2)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'Strategy':
        """Create from JSON string."""
        return cls.from_dict(json.loads(json_str))


@dataclass
class Trade:
    """A trade generated by the strategy.
    
    Attributes:
        timestamp: When the trade was triggered
        type: 'entry' or 'exit'
        price: Price at which trade occurred
        reason: Which condition triggered the trade
        metadata: Additional trade information
    """
    timestamp: str
    type: Literal["entry", "exit"]
    price: float
    reason: str
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "timestamp": self.timestamp,
            "type": self.type,
            "price": self.price,
            "reason": self.reason,
            "metadata": self.metadata or {}
        }


class StrategyEngine:
    """Unified strategy execution engine for backtest and replay modes.
    
    This engine ensures that the same logic is used regardless of whether
    the strategy is being backtested on historical data or executed in
    replay mode. The key principle is point-in-time evaluation - at each
    timestamp, only data up to that point is available.
    
    Usage:
        engine = StrategyEngine(strategy)
        results = engine.execute(data, mode="backtest")
    """
    
    def __init__(self, strategy: Strategy):
        """Initialize engine with a strategy.
        
        Args:
            strategy: The strategy to execute
        """
        self.strategy = strategy
        self.in_position = False
        self.trades: List[Trade] = []
        self.current_bar = 0
        
    def execute(
        self, 
        data: List[Dict[str, Any]], 
        mode: Literal["backtest", "replay"] = "backtest"
    ) -> Dict[str, Any]:
        """Execute strategy on data.
        
        Args:
            data: List of bars/candles with OHLCV data
            mode: Execution mode (backtest or replay)
            
        Returns:
            Results dictionary with trades and statistics
        """
        logger.info(f"Executing strategy '{self.strategy.name}' in {mode} mode")
        
        # Reset state
        self.in_position = False
        self.trades = []
        self.current_bar = 0
        
        # Process each bar sequentially (point-in-time)
        for i, bar in enumerate(data):
            self.current_bar = i
            
            # Only look at data up to current bar (no future leakage)
            available_data = data[:i+1]
            
            # Check entry conditions if not in position
            if not self.in_position:
                if self._check_conditions(self.strategy.entry_conditions, bar, available_data):
                    self._enter_trade(bar)
            
            # Check exit conditions if in position
            else:
                if self._check_conditions(self.strategy.exit_conditions, bar, available_data):
                    self._exit_trade(bar)
        
        # Close any open position at end
        if self.in_position and len(data) > 0:
            self._exit_trade(data[-1], reason="End of data")
        
        # Calculate statistics
        stats = self._calculate_statistics()
        
        return {
            "strategy": self.strategy.name,
            "mode": mode,
            "trades": [t.to_dict() for t in self.trades],
            "statistics": stats
        }
    
    def _check_conditions(
        self, 
        conditions: List[Condition], 
        bar: Dict[str, Any],
        available_data: List[Dict[str, Any]]
    ) -> bool:
        """Check if all conditions are met.
        
        Args:
            conditions: List of conditions to check
            bar: Current bar data
            available_data: All data up to current bar
            
        Returns:
            True if all conditions are met
        """
        if not conditions:
            return False
        
        # All conditions must be True (AND logic by default)
        for condition in conditions:
            if not self._evaluate_condition(condition, bar, available_data):
                return False
        
        return True
    
    def _evaluate_condition(
        self,
        condition: Condition,
        bar: Dict[str, Any],
        available_data: List[Dict[str, Any]]
    ) -> bool:
        """Evaluate a single condition.
        
        Args:
            condition: Condition to evaluate
            bar: Current bar data
            available_data: All data up to current bar
            
        Returns:
            True if condition is met
        """
        ctype = condition.type
        params = condition.params
        
        # Price comparisons
        if ctype == ConditionType.PRICE_ABOVE.value:
            return bar.get("close", 0) > params.get("value", 0)
        
        elif ctype == ConditionType.PRICE_BELOW.value:
            return bar.get("close", 0) < params.get("value", 0)
        
        elif ctype == ConditionType.PRICE_CROSSES_ABOVE.value:
            if len(available_data) < 2:
                return False
            prev_bar = available_data[-2]
            value = params.get("value", 0)
            return (prev_bar.get("close", 0) <= value and 
                    bar.get("close", 0) > value)
        
        elif ctype == ConditionType.PRICE_CROSSES_BELOW.value:
            if len(available_data) < 2:
                return False
            prev_bar = available_data[-2]
            value = params.get("value", 0)
            return (prev_bar.get("close", 0) >= value and 
                    bar.get("close", 0) < value)
        
        # Indicator comparisons (using calculated indicators)
        elif ctype == ConditionType.INDICATOR_ABOVE.value:
            indicator_name = params.get("indicator")
            value = params.get("value", 0)
            indicator_value = bar.get(indicator_name, 0)
            return indicator_value > value
        
        elif ctype == ConditionType.INDICATOR_BELOW.value:
            indicator_name = params.get("indicator")
            value = params.get("value", 0)
            indicator_value = bar.get(indicator_name, 0)
            return indicator_value < value
        
        elif ctype == ConditionType.INDICATOR_CROSSES_ABOVE.value:
            if len(available_data) < 2:
                return False
            indicator_name = params.get("indicator")
            value_param = params.get("value", 0)
            prev_bar = available_data[-2]
            
            # Check if value is another indicator name or a constant
            if isinstance(value_param, str):
                # It's another indicator name
                prev_value = prev_bar.get(value_param, 0)
                curr_value = bar.get(value_param, 0)
            else:
                # It's a constant
                prev_value = value_param
                curr_value = value_param
            
            return (prev_bar.get(indicator_name, 0) <= prev_value and 
                    bar.get(indicator_name, 0) > curr_value)
        
        elif ctype == ConditionType.INDICATOR_CROSSES_BELOW.value:
            if len(available_data) < 2:
                return False
            indicator_name = params.get("indicator")
            value_param = params.get("value", 0)
            prev_bar = available_data[-2]
            
            # Check if value is another indicator name or a constant
            if isinstance(value_param, str):
                # It's another indicator name
                prev_value = prev_bar.get(value_param, 0)
                curr_value = bar.get(value_param, 0)
            else:
                # It's a constant
                prev_value = value_param
                curr_value = value_param
            
            return (prev_bar.get(indicator_name, 0) >= prev_value and 
                    bar.get(indicator_name, 0) < curr_value)
        
        # Logical operators
        elif ctype == ConditionType.AND.value:
            if not condition.children:
                return True
            return all(
                self._evaluate_condition(c, bar, available_data) 
                for c in condition.children
            )
        
        elif ctype == ConditionType.OR.value:
            if not condition.children:
                return False
            return any(
                self._evaluate_condition(c, bar, available_data) 
                for c in condition.children
            )
        
        elif ctype == ConditionType.NOT.value:
            if not condition.children or len(condition.children) == 0:
                return True
            return not self._evaluate_condition(condition.children[0], bar, available_data)
        
        else:
            logger.warning(f"Unknown condition type: {ctype}")
            return False
    
    def _enter_trade(self, bar: Dict[str, Any], reason: str = "Entry condition met"):
        """Enter a trade.
        
        Args:
            bar: Current bar data
            reason: Reason for entry
        """
        trade = Trade(
            timestamp=bar.get("timestamp", ""),
            type="entry",
            price=bar.get("close", 0),
            reason=reason
        )
        self.trades.append(trade)
        self.in_position = True
        logger.debug(f"Entered trade at {trade.price}")
    
    def _exit_trade(self, bar: Dict[str, Any], reason: str = "Exit condition met"):
        """Exit a trade.
        
        Args:
            bar: Current bar data
            reason: Reason for exit
        """
        trade = Trade(
            timestamp=bar.get("timestamp", ""),
            type="exit",
            price=bar.get("close", 0),
            reason=reason
        )
        self.trades.append(trade)
        self.in_position = False
        logger.debug(f"Exited trade at {trade.price}")
    
    def _calculate_statistics(self) -> Dict[str, Any]:
        """Calculate performance statistics.
        
        Returns:
            Dictionary of statistics
        """
        if not self.trades:
            return {
                "total_trades": 0,
                "winning_trades": 0,
                "losing_trades": 0,
                "win_rate": 0.0
            }
        
        # Pair entries and exits
        entries = [t for t in self.trades if t.type == "entry"]
        exits = [t for t in self.trades if t.type == "exit"]
        
        total_trades = len(entries)
        winning_trades = 0
        losing_trades = 0
        
        for i in range(min(len(entries), len(exits))):
            pnl = exits[i].price - entries[i].price
            if pnl > 0:
                winning_trades += 1
            elif pnl < 0:
                losing_trades += 1
        
        win_rate = winning_trades / total_trades if total_trades > 0 else 0.0
        
        return {
            "total_trades": total_trades,
            "winning_trades": winning_trades,
            "losing_trades": losing_trades,
            "win_rate": win_rate
        }


# Strategy storage functions
def get_strategies_dir() -> Path:
    """Get the strategies storage directory.
    
    Returns:
        Path to strategies directory
    """
    # Store strategies in a 'strategies' directory at the root
    strategies_dir = Path(__file__).parent.parent / "strategies"
    strategies_dir.mkdir(exist_ok=True)
    return strategies_dir


def save_strategy(strategy: Strategy, strategy_id: Optional[str] = None) -> str:
    """Save a strategy to disk.
    
    Args:
        strategy: Strategy to save
        strategy_id: Optional ID for the strategy (defaults to name)
        
    Returns:
        Strategy ID
    """
    if strategy_id is None:
        # Generate ID from name (sanitize for filesystem)
        strategy_id = strategy.name.lower().replace(" ", "_")
    
    strategies_dir = get_strategies_dir()
    strategy_path = strategies_dir / f"{strategy_id}.json"
    
    # Save as JSON
    with open(strategy_path, "w") as f:
        f.write(strategy.to_json())
    
    logger.info(f"Saved strategy '{strategy.name}' to {strategy_path}")
    return strategy_id


def load_strategy(strategy_id: str) -> Strategy:
    """Load a strategy from disk.
    
    Args:
        strategy_id: ID of the strategy to load
        
    Returns:
        Loaded strategy
        
    Raises:
        FileNotFoundError: If strategy doesn't exist
    """
    strategies_dir = get_strategies_dir()
    strategy_path = strategies_dir / f"{strategy_id}.json"
    
    if not strategy_path.exists():
        raise FileNotFoundError(f"Strategy '{strategy_id}' not found")
    
    with open(strategy_path, "r") as f:
        json_str = f.read()
    
    strategy = Strategy.from_json(json_str)
    logger.info(f"Loaded strategy '{strategy.name}' from {strategy_path}")
    return strategy


def list_strategies() -> List[Dict[str, str]]:
    """List all saved strategies.
    
    Returns:
        List of strategy metadata
    """
    strategies_dir = get_strategies_dir()
    strategies = []
    
    for strategy_path in strategies_dir.glob("*.json"):
        try:
            with open(strategy_path, "r") as f:
                data = json.load(f)
            
            strategies.append({
                "id": strategy_path.stem,
                "name": data.get("name", "Unknown"),
                "description": data.get("description", ""),
                "created_at": data.get("metadata", {}).get("created_at", "")
            })
        except Exception as e:
            logger.warning(f"Failed to load strategy {strategy_path}: {e}")
    
    return strategies


def delete_strategy(strategy_id: str) -> bool:
    """Delete a strategy from disk.
    
    Args:
        strategy_id: ID of the strategy to delete
        
    Returns:
        True if deleted successfully
    """
    strategies_dir = get_strategies_dir()
    strategy_path = strategies_dir / f"{strategy_id}.json"
    
    if not strategy_path.exists():
        return False
    
    strategy_path.unlink()
    logger.info(f"Deleted strategy '{strategy_id}'")
    return True
